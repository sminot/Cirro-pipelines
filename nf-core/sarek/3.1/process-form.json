{
  "ui": {
    "analysis_type": {
      "tools": {
        "ui:widget": "checkboxes"
      }
    },
    "annotation": {
      "annotation_tool": {
        "ui:widget": "checkboxes"
      }
    },
    "read_trimming_options": {
      "trim_fastq": {
        "ui:widget": "radio"
      }
    }
  },
  "form": {
    "title": "Variant Calling (nf-core/sarek)",
    "description": "Perform variant calling on unaligned sequence reads",
    "type": "object",
    "properties": {
      "workflow_version": {
        "type": "string",
        "title": "Workflow Version",
        "description": "Select the specific version of nf-core/sarek used for analysis",
        "enum": [
          "3.1",
          "3.1.1",
          "3.1.2",
          "3.2.3",
          "3.3.2",
          "3.4.4",
          "3.5.1",
          "3.6.0",
          "3.6.1"
        ],
        "default": "3.6.1"
      },
      "analysis_type": {
        "title": "Experiment Design",
        "description": "Indicate the analysis type (germline/somatic) and select high level parameters for the workflow.",
        "type": "object",
        "required": ["genome", "analysis_type", "tools", "wes"],
        "properties": {
          "genome": {
            "title": "Reference Genome",
            "type": "string",
            "default": "GATK.GRCh38",
            "enum": ["GATK.GRCh38", "GATK.GRCh37", "GRCm38"],
            "enumNames": [
              "Homo sapiens (GATK.GRCh38)",
              "Homo sapiens (GATK.GRCh37)",
              "Mus musculus (GRCm38)"
            ]
          },
          "wes": {
            "title": "Whole Exome/Targeted Gene Panel Assay",
            "description": "Please indicate if your data was generated using a capture kit.",
            "type": "boolean",
            "default": false
          },
          "intervals": {
            "title": "Genomic intervals",
            "description": "Target bed file in case of whole exome or targeted sequencing or intervals file for parallelization.",
            "type": "string",
            "pathType": "references",
            "file": "**/genome_bed/**/regions.bed"
          },
          "germline_resource": {
            "title": "Germline resource",
            "description": "The germline resource VCF file (bgzipped and tabixed) needed by GATK4 Mutect2 is a collection of calls that are likely present in the sample, with allele frequencies.",
            "type": "string",
            "pathType": "references",
            "file": "**/germline_resource/**/germline_resource.vcf.gz"
          },
          "analysis_type": {
            "title": "Variant Calling Type",
            "default": "Germline Variant Calling",
            "enum": ["Germline Variant Calling", "Somatic Variant Calling"]
          }
        },
        "allOf": [
          {
            "if": {
              "properties": {
                "analysis_type": {
                  "const": "Germline Variant Calling"
                }
              }
            },
            "then": {
              "properties": {
                "tools": {
                  "title": "Germline variant calling tool(s)",
                  "description": "Please select one or more variant callers for your analysis.",
                  "type": "array",
                  "pattern": "^((cnvkit|deepvariant|freebayes|haplotypecaller|manta|mpileup|strelka|tiddit)*,?)*$",
                  "items": {
                    "type": "string",
                    "enum": [
                      "cnvkit",
                      "deepvariant",
                      "freebayes",
                      "haplotypecaller",
                      "manta",
                      "mpileup",
                      "strelka",
                      "tiddit"
                    ],
                    "enumNames": [
                      "CNVkit",
                      "DeepVariant",
                      "FreeBayes",
                      "HaplotypeCaller",
                      "Manta",
                      "mpileup",
                      "Strelka",
                      "TIDDIT"
                    ]
                  },
                  "uniqueItems": true
                }
              }
            }
          },
          {
            "if": {
              "properties": {
                "analysis_type": {
                  "const": "Somatic Variant Calling"
                }
              }
            },
            "then": {
              "properties": {
                "tools": {
                  "title": "Somatic variant calling tool(s)",
                  "description": "Please select one or more variant callers for your analysis.",
                  "type": "array",
                  "pattern": "^((ascat|controlfreec|cnvkit|freebayes|manta|msisensorpro|mutect2|strelka|tiddit)*,?)*$",
                  "items": {
                    "type": "string",
                    "enum": [
                      "ascat",
                      "controlfreec",
                      "cnvkit",
                      "freebayes",
                      "manta",
                      "msisensorpro",
                      "mutect2",
                      "strelka",
                      "tiddit"
                    ],
                    "enumNames": [
                      "ASCAT",
                      "Control-FREEC",
                      "CNVkit",
                      "FreeBayes",
                      "Manta",
                      "MSIsensorpro",
                      "Mutect2",
                      "Strelka",
                      "TIDDIT"
                    ]
                  },
                  "uniqueItems": true
                }
              }
            }
          }
        ]
      },
      "annotation": {
        "title": "Variant Annotation",
        "description": "Select variant annotation tools and VEP plugins.",
        "type": "object",
        "properties": {
          "annotation_tool": {
            "title": "Annotation tool(s)",
            "description": "Please select one or both variant annotation tools.",
            "type": "array",
            "pattern": "^((vep|snpeff)*,?)*$",
            "items": {
              "type": "string",
              "enum": ["vep", "snpeff"],
              "enumNames": ["Variant Effect Predictor (VEP)", "snpEff"]
            },
            "uniqueItems": true
          }
        },
        "if": {
          "properties": {
            "annotation_tool": {
              "contains": {
                "type": "string",
                "const": "vep"
              }
            }
          }
        },
        "then": {
          "properties": {
            "vep_dbnsfp": {
              "type": "boolean",
              "title": "dbNSFP plugin",
              "description": "Enable the use of the VEP dbNSFP plugin that retrieves data for missense variants.",
              "default": false
            },
            "vep_loftee": {
              "type": "boolean",
              "title": "LOFTEE plugin",
              "description": "Enable the use of the VEP LOFTEE plugin to identify LoF (loss-of-function) variation.",
              "default": false
            },
            "vep_spliceai": {
              "type": "boolean",
              "title": "SpliceAI plugin",
              "description": "Enable the use of the VEP SpliceAI plugin to annotate variants predicted effect on splicing.",
              "default": false
            },
            "vep_spliceregion": {
              "type": "boolean",
              "title": "SpliceRegion plugin",
              "description": "Enable the use of the VEP SpliceRegion plugin to provide granular predictions of splicing effects.",
              "default": false
            }
          }
        }
      },
      "read_trimming_options": {
        "title": "Read Trimming Options",
        "description": "Parameters for performing adapter and read trimming using Trim-Galore.",
        "type": "object",
        "properties": {
          "trim_fastq": {
            "type": "boolean",
            "title": "Trim reads using Trim-Galore?",
            "default": false
          }
        },
        "dependencies": {
          "trim_fastq": {
            "oneOf": [
              {
                "properties": {
                  "trim_fastq": {
                    "enum": [false]
                  }
                }
              },
              {
                "properties": {
                  "trim_fastq": {
                    "enum": [true]
                  },
                  "clip_r1": {
                    "type": "integer",
                    "title": "Clip R1",
                    "description": "Instructs Trim Galore to remove bp from the 5' end of read 1 (or single-end reads)."
                  },
                  "clip_r2": {
                    "type": "integer",
                    "title": "Clip R2",
                    "description": "Instructs Trim Galore to remove bp from the 5' end of read 2 (paired-end reads only)."
                  },
                  "three_prime_clip_r1": {
                    "type": "integer",
                    "title": "Three Prime Clip R1",
                    "description": "Instructs Trim Galore to remove bp from the 3' end of read 1 AFTER adapter/quality trimming has been performed."
                  },
                  "three_prime_clip_r2": {
                    "type": "integer",
                    "title": "Three Prime Clip R2",
                    "description": "Instructs Trim Galore to remove bp from the 3' end of read 2 AFTER adapter/quality trimming has been performed."
                  },
                  "trim_nextseq": {
                    "type": "boolean",
                    "title": "Trim NextSeq",
                    "description": "DetectS polyG in read tails and trim them. Corresponds to the FastP flag `--trim_poly_g.`"
                  },
                  "save_trimmed": {
                    "type": "boolean",
                    "title": "Save the trimmed FastQ files in the results directory?",
                    "default": false
                  }
                }
              }
            ]
          }
        }
      },
      "umi_options": {
        "type": "object",
        "title": "Unique Molecular Identifiers",
        "description": "Options for handling Unique Molecular Identifiers (UMIs) in the workflow.",
        "properties": {
          "umi_in_read_header": {
            "type": "boolean",
            "title": "UMI in Read Header",
            "description": "Move UMIs from fastq read headers to a tag prior to deduplication. Set to true if UMIs are already present in the header of the read, for instance from using OverrideCycles in bclconvert or umi_tools/extract.",
            "default": false
          },
          "use_fgbio": {
            "type": "boolean",
            "title": "Use fgbio for UMI processing",
            "description": "Enable UMI processing using fgbio tools for consensus read generation and deduplication.",
            "default": false
          },
          "use_fastp": {
            "type": "boolean",
            "title": "Use fastp for UMI extraction",
            "description": "Enable UMI extraction from reads using fastp prior to alignment.",
            "default": false
          }
        },
        "dependencies": {
          "use_fgbio": {
            "oneOf": [
              {
                "properties": {
                  "use_fgbio": {
                    "enum": [true]
                  },
                  "umi_read_structure": {
                    "type": "string",
                    "title": "UMI Read Structure",
                    "description": "Specify UMI read structure for fgbio UMI consensus read generation. One structure if UMI is present on one end (i.e. '+T 2M11S+T'), or two structures separated by a blank space if UMIs a present on both ends (i.e. '2M11S+T 2M11S+T'); please note, this does not handle duplex-UMIs."
                  },
                  "group_by_umi_strategy": {
                    "type": "string",
                    "title": "Group by UMI Strategy",
                    "default": "Adjacency",
                    "description": "Default strategy for fgbio UMI-based consensus read generation ",
                    "enum": ["Identity", "Edit", "Adjacency", "Paired"]
                  }
                }
              },
              {
                "properties": {
                  "use_fgbio": {
                    "enum": [false]
                  }
                }
              }
            ]
          },
          "use_fastp": {
            "oneOf": [
              {
                "properties": {
                  "use_fastp": {
                    "enum": [true]
                  },
                  "umi_location": {
                    "type": "string",
                    "title": "UMI Location",
                    "description": "Location of the UMI(s) to be extracted with fastp. Use if UMIs are not present in the read header, but in a specific location within the reads/fastq header index. This will be used to extract UMIs from reads or index in the fastq header and store them in the RX tag.",
                    "default": "read1",
                    "enum": ["read1", "read2", "per_read", "index1", "index2", "per_index"]
                  },
                  "umi_length": {
                    "type": "integer",
                    "title": "UMI Length",
                    "description": "Length of the UMI(s) in the read. If UMIs are being extracted using fastp, specify the length of the UMI here. This will be used to extract UMIs from reads and store them in the RX tag."
                  },
                  "umi_base_skip": {
                    "type": "integer",
                    "title": "UMI Base Skip",
                    "description": "Number of bases to skip after the UMI(s) in the read when extracting with fastp. If UMIs are being extracted using fastp, specify the number of bases to skip after the UMI here. This will trim some bases after the UMI."
                  }
                }
              },
              {
                "properties": {
                  "use_fastp": {
                    "enum": [false]
                  }
                }
              }
            ]
          }
      }
    },
    "advanced_options": {
        "type": "object",
        "title": "Advanced Options",
        "properties": {
          "optical_duplicate_pixel_distance": {
            "type": "integer",
            "title": "MarkDuplicates - Optical Duplicate Pixel Distance",
            "description": "The `--OPTICAL_DUPLICATE_PIXEL_DISTANCE` parameter is used by MarkDuplicates to set the maximum offset between two duplicate clusters in pixels for them to be considered optical duplicates. A value of 100 is generally appropriate for unpatterned Illumina flowcells and 250 is appropriate for patterned Illumina flow cells.",
            "default": 100
          }
        }
      }
    }
  }
}
